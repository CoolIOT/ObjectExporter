<#@ template language="C#" #>
<#@ parameter name="objectExpression" type="EnvDTE.Expression" #>
<#@ parameter name="maxDepth" type="System.Int32" #>
<#@ parameter name="excludePrivates" type="System.Boolean" #>
<#@ assembly name="System.Core" #>
<#@ import namespace="System.Linq" #>
<#@ import namespace="System.Text" #>
<#@ import namespace="EnvDTE" #>
<#@ import namespace="System.Collections.Generic" #>
<?xml version="1.0" encoding="utf-8"?>
<# ExportMembers(objectExpression, 0); #>
<#+
    bool isFirstElement = true;

    public void ExportMembers(Expression expression, int recursionLevel)
    {
        //members of objects have a type of: object { theType } - Strip out object { }
        string expressionType = GeneratorHelper.StripObjectReference(expression.Type);

        if(!GeneratorHelper.IsSerializable(expression.Name))
        {
            return;
        }
        else if(expression.Value == "null")
        {
            return;
        }
        else if(GeneratorHelper.CanBeExpressedAsSingleType(expressionType))
        {
            WriteLine("");
            if(GeneratorHelper.IsCollectionMember(expression.Name))
            {
                #><<#= expressionType #>><#= GetSingleTypeValue(expression) #></<#= expressionType #>><#+
            }
            else
            {
                #><<#= expression.Name #>><#= GetSingleTypeValue(expression) #></<#= expression.Name #>><#+
            }
        }
        else if (expression.DataMembers.Count == 0)
        {
            WriteLine("");
            string node = expression.Name;
            if(GeneratorHelper.IsCollectionMember(expression.Name))
            {
                node = expressionType;
            }

            #><<#= node #>><#= expression.Value #></<#= node #>><#+
        }
        else if (expression.DataMembers.Count > 0 && recursionLevel <= maxDepth)
        {
            //used for the very first object (top most) to be completed as var objName = new objType, without a space in between.
            if(isFirstElement)
            {
                isFirstElement = false;
            }
            else
            {
                WriteLine("");
            }

            string node = expressionType;
            if(GeneratorHelper.IsTypeOfCollection(expressionType) && !GeneratorHelper.IsCollectionMember(expression.Name))
            {
                node = expression.Name;
            }

            List<Expression> cleanedExpressionMembers = GeneratorHelper.SanitizeExpressions(expression, _propertyAccessibilityChecker, excludePrivates, expressionType);
        
            #><<#= node #>><#+
            foreach(Expression exp in cleanedExpressionMembers)
            {
                PushIndent("\t");
                ExportMembers(exp, recursionLevel + 1);
                PopIndent();
            }
            WriteLine("");
            #></<#= node #>><#+
        }
    }
#>