<#@ template language="C#" #>
<#@ parameter name="objectExpression" type="EnvDTE.Expression" #>
<#@ parameter name="maxDepth" type="System.Int32" #>
<#@ parameter name="excludePrivates" type="System.Boolean" #>
<#@ assembly name="System.Core" #>
<#@ import namespace="System.Linq" #>
<#@ import namespace="System.Text" #>
<#@ import namespace="EnvDTE" #>
<#@ import namespace="System.Collections.Generic" #>
<#
    if(CanBeExpressedAsSingleType(objectExpression.Type) || objectExpression.DataMembers.Count == 0)
    {
        ExportMembers(objectExpression, 0, true);
    }
    else
    {
        #>var <#= GeneratorHelper.ResolveReservedNames(objectExpression.Name) #> = <#
        ExportMembers(objectExpression, 0, true);
    }
#>;
<#+
    bool isFirstElement = true;

    public void ExportMembers(Expression expression, int recursionLevel, bool isLast)
    {
        //resolved reserved keywords such as class, this becomes @class.
        string expressionName = GeneratorHelper.ResolveReservedNames(expression.Name);
        //members of objects have a type of: object { theType } - Strip out object { }
        string expressionType = GeneratorHelper.StripObjectReference(expression.Type);

        if(!GeneratorHelper.IsSerializable(expressionName))
        {
            return;
        }
        else if(CanBeExpressedAsSingleType(expressionType))
        {
            WriteLine("");
            
            if(GeneratorHelper.IsCollectionMember(expressionName))
            {
                #><#= GetSingleTypeValue(expression) + GeneratorHelper.WriteCommaIfNotLast(isLast) #><#+
            }
            else
            {
                #><#= expressionName #> = <#= GetSingleTypeValue(expression) + GeneratorHelper.WriteCommaIfNotLast(isLast) #><#+
            }
        }
        else if (expression.DataMembers.Count == 0)
        {
            WriteLine("");
            if(GeneratorHelper.IsCollectionMember(expressionName))
            {
                #><#= expression.Value + GeneratorHelper.WriteCommaIfNotLast(isLast) #><#+
            }
            else
            {   
                #><#= expressionName #> = <#= expression.Value + GeneratorHelper.WriteCommaIfNotLast(isLast) #><#+
            }
        }
        else if (expression.DataMembers.Count > 0 && recursionLevel <= maxDepth)
        {
            //used for the very first object (top most) to be completed as var objName = new objType, without a space in between.
            if(isFirstElement)
            {
                isFirstElement = false;
            }
            else
            {
                WriteLine("");
            }

            if(GeneratorHelper.IsTypeOfCollection(expressionType) && !GeneratorHelper.IsCollectionMember(expressionName))
            {
                #><#= expressionName #> = new <#= expressionType #><#+ 
                WriteLine(""); #>{<#+
            }
            else
            {
                #>new <#= expressionType #><#+
                WriteLine(""); #>{<#+
            }

            var expressionMembers = expression.DataMembers.Cast<Expression>().ToList();
            var cleanedExpressionMembers = new List<Expression>();

            for(int i = 0; i < expressionMembers.Count; i++)
            {
                Expression currentExpression = expressionMembers[i];
                
                //Add base type members to the list at the current level
                if(GeneratorHelper.IsBase(currentExpression))
                {
                    expressionMembers.AddRange(currentExpression.DataMembers.Cast<Expression>());
                }
                else if(GeneratorHelper.IsSerializable(currentExpression.Name))
                {
                    if(excludePrivates)
                    {
                        //check accessibility
                        bool isAccesible = _propertyAccessibilityChecker.IsAccessiblePropertyOrField(currentExpression.Name, expressionType);

                        if(isAccesible)
                        {
                            cleanedExpressionMembers.Add(currentExpression);
                        }
                    }
                    else //Add all (including private)
                    {
                        cleanedExpressionMembers.Add(currentExpression);
                    }
                }
            }

            foreach(Expression exp in cleanedExpressionMembers)
            {
                PushIndent("\t");
                bool isLastItem = cleanedExpressionMembers.IsLast(exp);
                ExportMembers(exp, recursionLevel + 1, isLastItem);
                PopIndent();
            }

            WriteLine("");
            #>}<#+
            #><#= GeneratorHelper.WriteCommaIfNotLast(isLast) #><#+
        }
    }
#>